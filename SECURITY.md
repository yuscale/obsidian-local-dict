
碳基生命交流圈

> 原文件名：carbon-based.md，为了显示在这里，改名了。

整个扩展都是在ai的帮助下完成的，最开始只想简略的再ob中显示一下mdx文件，方便查看。就写了几个最基础的要求给了ai们。让其输出ob的扩展程序代码，最开丧床测试就是直接扔进vscode，看有没有报错，如果没有就能继续。如果直接开始就有一堆错误，就直接淘汰。(后来才知道，VSCode 的要求太高，很多不影响编译的也会报错，估计冤枉了不少好ai)
后续就是在这个基础上添砖加瓦，最终成了个这个东东。有一点先要说明一下，所有的ai均是非订阅状态下的账号，这个我瘪瘪的钱包能证明。这些真正适合大众平时使用的ai，能毫无顾忌的使用。当然，使用过程中还是有一些厂商赠送限量使用权，几天的重度使用就能频繁的遇到提示开通付费账号权限的提示。不过最基础的免费版还是能打的，伴随我几天时间，并最终完成了这个ob本地词典插件。
开始使用的ai选手有copilot，ChatGPT，gemini和grok。一开始对于ob的扩展也不了解，直接将生成的代码粘贴到vscode，直接就看有几个错误。遇到没有错误的ChatGPT就将其作为主要选手了。其余各位时常帮个小忙，也没闲着。
最开始只是想着能在ob中看看单词的汉语意思就行了，想着将本地服务的返回值显示在一个边栏里就行了。也没想着太多，就是双击一下单词就直接显示意思，方便。不过在选词典时发现了这个`韦泊英汉快查词典 0.2i`，默认只显示汉语意思，实际上还包括详细的双解内容和双语例句。之后就想着能不能切换显示一下，有时候有点英语语境能更准确的理解单词的意思。就这样一点儿一点儿各种功能就来了，复制成md，查询，历史记录，等等。随着功能越来越多，和ai的对话越来越长，上下文越来越复杂，ai的反应也越来越慢。
在完成了后续的readme之后，我又对插件进行了一些小修改，变成是真的发现了一些小bug，不过此时的ai更慢了，搞得我有点着急。

初期只是想使用特定的词典，所以在实现的时候好多都是硬编码，都是写死的，变不了一点儿。想到以后贪婪的自己，肯定要这要那，这个实现就太简陋了，慢慢的将其中的死参数逐渐改成能变的，虽然很多不能自动识别，但是至少时能在设置中改了。对了，这个扩展最开始是没有设置界面的，直到有一次我把他关了，就一直打不开了。只能在插件管理中先停用再启用。在初期阶段最常用的就是这个方法了，这个过程能重新加载修改后的插件，检查修改有没有起效果。后来发现在调试工具中使用快捷键能实现更彻底的重新载入，就放弃这个点来点去的操作流程了。
嘿嘿，其实设置界面和打开扩展没有啥关系，真正实现打开操作的是添加一个命令，有了这个命令就能再次打开扩展了。实际上在逐渐加强插件功能的过程中，一直都只有这一个命令，直到最后差不所要完成了，才将所能想到的操作都添加了命令，方便后续关联快捷键，咱没有默认的快捷键，但不能没有设置快捷键的能力。
将原始写死的变量改成能修改的参数，这就有了设置界面。逐渐的越来越多的硬参数都变成了一个个可以修改并自定义的参数，最终变成了设置界面中一个个文本输入框。
在此阶段，最重要的目的就是控制词典界面显示的内容，不想让其显示的，将其替换为空值，想换一种显示显示样式的，给他换一种属性。包括后续实现md输出，也使用了替换大法将不需要的字符删掉。控制最终的显示效果。

在此阶段使用了大量的替换，主要的目的就是在后续的使用中，保留最大限度的自由。使用正则表达式，能完成你所想要的全部功能。
但是想到的一个具体的点就是在后续的使用中会更换词典，这样样就能实现不同词典的使用。就是得一个一个网页元素的分析，好在大多数词典都有配套的css文件，使之能事半功倍。

在进行到后半程时，还让ai将之前所提出的功能要求进行汇总，没想到啊，这一句一句的零散要求竟然汇总除了一个20项的列表。

<details>
  <summary>**Caution for ai-generated content!**</summary>

> **输出结果**
>
>|功能编号| 功能描述                                                                            |
>| ------ | ------------------------------------------------------------------------------- |
>| **1**  | 插件加载后，**自动在右栏打开一个视图**（类型为 `local-dict-viewer`）                                  |
>| **2**  | 支持在编辑器中 **双击选中单词** 触发查词请求                                                       |
>| **3**  | 查询接口为本地服务：`http://localhost:2628/api/query/WM/{word}`，**返回 HTML**               |
>| **4**  | 原始 HTML 内容直接显示在右栏中（**不转 Markdown**，保留样式结构）                                      |
>| **5**  | 显示区域支持 **文字选中复制、滚动查看**，不被按钮遮挡                                                   |
>| **6**  | 显示区域顶部有两个固定按钮：**“复制全部”** 和 **“复制简略”**，始终可见，不随滚动移动                               |
>| **7**  | 点击 “复制全部”：将原始 HTML → Markdown，做简单文本清理 → 复制到剪贴板                                  |
>| **8**  | 点击 “复制简略”：将 HTML 按预设的 CSS 规则简化（去掉 `display:none` 的元素）→ Markdown → 清理文本 → 复制到剪贴板 |
>| **9**  | HTML 简化逻辑 **精确模拟** CSS 中的隐藏选择器逻辑（如：`.sblocks~.dros`、`.mw_zh~.un_text .mw_zh`）   |
>| **10** | 渲染区域使用统一样式类名 `.local-dict-html` 包裹，方便控制样式与布局                                    |
>| **11** | 不使用内联样式（如 `<style>` 标签）污染 HTML，统一清理后输出                                          |
>| **12** | 插件样式使用 `styles.css` 中定义的类控制：按钮样式、固定顶部、内容样式等                                     |
>| **13** | 关闭右栏后，插件仍可通过插件重新激活视图（右栏保持唯一、可重复使用）                                              |
>| **14** | 所有 TypeScript 编译、Rollup 打包可正常通过，无语法或类型错误                                        |
>| **15** | 插件支持 Obsidian 的热重载机制，开发时可启用“开发者模式”快速调试                                          |
>| **16** | 插件结构标准，包含完整 `manifest.json`，遵循 Obsidian 插件规范                                    |
>| **17** | 使用 `Turndown` 将 HTML 转 Markdown（用于复制功能）                                         |
>| **18** | 插件可独立运行，无需外部服务，只依赖本地提供的词典 HTTP 接口                                               |
>| **19** | 渲染区域可控制空白字符与段落间距，避免过多空行或行距异常                                                    |
>| **20** | 插件使用现代 Obsidian API，确保兼容性（minAppVersion ≥ 0.15.0）                               |
>
</details>

不过在此基础上，我还是增加了几条。

<details>
  <summary>**Caution for ai-generated content!**</summary>

> **输出结果**（后几条是我自己加的）
>
>在 windows 下，帮我写一个 obsidian 扩展，实现以下功能
>功能描述
>
> 1. 插件加载后，**自动在右栏打开一个视图**（类型为 `local-dict-viewer`）
> 2. 支持在编辑器中 **双击选中单词** 触发查词请求
> 3. 查询接口为本地服务：`http://localhost:2628/api/query/WM/{word}`，**返回 HTML**
> 4. 原始 HTML 内容直接显示在右栏中,html 中有css style部分，需要去掉,（**不转 Markdown**，保留样式结构）
> 5. 显示区域支持 **文字选中复制、滚动查看**，不被按钮遮挡
> 6. 显示区域顶部有两个固定按钮：**“复制全部”** 和 **“复制简略”**，始终可见，不随滚动移动
> 7. 点击 “复制全部”：将原始 HTML → Markdown，做简单文本清理 → 复制到剪贴板
> 8. 点击 “复制简略”：将 HTML 按预设的 CSS 规则简化（去掉 `display:none` 的元素）→ Markdown → 清理文本
> 9. HTML 简化逻辑 **精确模拟** CSS 中的隐藏选择器逻辑（如：`.sblocks~.dros`、`.mw_zh~.un_text .mw_zh`）
> 10. 渲染区域使用统一样式类名 `.local-dict-html` 包裹，方便控制样式与布局
> 11. 不使用内联样式（如 `<style>` 标签）污染 HTML，统一清理后输出
> 12. 插件样式使用 `styles.css` 中定义的类控制：按钮样式、固定顶部、内容样式等
> 13. 关闭右栏后，插件仍可通过插件重新激活视图（右栏保持唯一、可重复使用）
> 14. 所有 TypeScript 编译、Rollup 打包可正常通过，无语法或类型错误
> 15. 插件支持 Obsidian 的热重载机制，开发时可启用“开发者模式”快速调试
> 16. 插件结构标准，包含完整 `manifest.json`，遵循 Obsidian 插件规范
> 17. 使用 `Turndown` 将 HTML 转 Markdown（用于复制功能）
> 18. 插件可独立运行，无需外部服务，只依赖本地提供的词典 HTTP 接口
> 19. 渲染区域可控制空白字符与段落间距，避免过多空行或行距异常
> 20. 插件使用现代 Obsidian API，确保兼容性（minAppVersion ≥ 0.15.0）
> 21. 定义在右边栏的图标，从ob图标库中选取
> 22. 屏蔽右边栏中的双击事件，让其还能选择
> 23. 在返回html结果中检查div class="article-block" 下，是否含有一个类似`<a href="/api/query/WM/wall">wall</a>`的连接，只查找div class="article-block"前三个字元素即可，如果存在，则说明需要进一步查询，将`<a>`中的词作为新的查询词，查询，并显示改新词的查询结果
> 24. 添加一个命令用于手动唤出右边栏视图
> 25. 在顶部添加一个按钮‘显示简略’,按下去后显示“显示全部” 按下显示简略后,将html中的 .hidden_text , .vis_w, .uro_def, .def_labels , .sblocks~.dros , .collapsed .collapsible , .mw_zh~.un_text .mw_zh , 几种元素隐藏,注意几个特殊的选择器关系, 按下“显示全部”后则显示没有隐藏前的html
> css 文件内容为
>
> ```
>    hidden_text ,
>    vis_w,
>    uro_def,
>    def_labels ,
>    sblocks~.dros ,
>    collapsed .collapsible ,
>    mw_zh~.un_text .mw_zh {
>       display: none;
> ```
>
> 26. 生成设置页面，主要包含一个文本输入框，默认值是`WM`。接受新的值使之替换本地服务连接中的 wm
> 27. 给出全部需要的文件
>
</details>

这时还是主要在实现显示和输出md功能呢。不过好在是ai生成的，外加ob插件的格式也比较简单明了，在后添加我认为很难很复杂的功能时，并没有费太大力气。也有另一个比较重要的原因，就是我已经习惯了如何与之交流，能很好的提出自己的功能需求。
要是一股脑儿的将一大堆需求发给ai，可能会给你一个差不多的回复，但是代码太长会让你难以一时半会儿就接受并理解。反而学会将需求进行分解，找到最基础的功能需求，然后再其上逐渐完善，才能更容易与ai配合。

………………
渐渐的，扩展逐渐成形，实现了事先未曾想到的一些功能。不过这一切都要归功于ChatGPT，所有的代码都是他输出的，我只是将其一点点组合成一个完整的程序，所有的bug也都是他修复的，我就是直接将错误代码返回给他，逐渐的代码越来越复杂，还发生了几次咋说我也找不到要修改的部分，就只能将几乎全部的代码一起喂给他，让他统一综合处理。别说这还真是个不错的方法，它能全面的分析代码，找出前后相互引用而出现的错误。

随着免费额度的耗尽，ai明显不能综合上下文来回答问题了，只顾眼前的小问题，丧失了统筹全局的能力，搞得我血压都上来了。

最终，待所有代码都输出完毕，那就连写说明文档的活一起干了吧。最终在几次修正要求的过程后，给出了还算可以的readme文档。
我只做了非常少量的修改与杂交，嗯，就是将不同版本的文档的优质内容放到一起。
最最终，就连生成GitHub项目的流程也要ai来教我。至此也算是有始有终的完成了一个开源项目。

我在这个不断与chatgpt交流的过程中，发现最重要也是最难的就是准确地描述出你想要实现的功能和效果，只要它足够具体，chatgpt都给你实现。相必也有我这些需求不太难满足的原因。

走路的时间长了，就容易忘了为什么出发。与ai对话久了，差点忘了最初搞这个插件的原因。就是双击查词，这个可以媲美一大堆的的查词软件了。但是搞着搞着就把这个点给忽略了。直到在让ai输出文档过程中，一次次的“详细点”，“在扩展一下”……的pua中，终于这个点又跳回了我的视线。当然附带的输出md到剪切板功能也很实用，其余的查询啦，历史记录啦什么的，聊胜于无。

就在刚刚，又有好几个非常棒的idea，但是不能为了需求而创造需求啊，在此仅作记录了：对按钮添加双击和右键相应;词典显示区的右键菜单功能增强。还是没忍住，又添加上了。现在大家看见的就是最后(假装的)完全体了。

不知何时由来修改这个插件了。最终，ai 都提示了:

> You've reached the maximum length for this conversation, but you can keep talking by starting a new chat.
> \<Retry\>

而且页面卡的让人难受了，应该关了这对话转战新的对话了，就实不知如何继承原有的数据信息，要是不能还要重新构建上下文。
多试了几次，直接思维混乱了，不知回答得是啥时候的提问了。不过到此，改进又一次结束了。这次主要是修正界面上元素的显示逻辑，一直很混乱。最后直接就用 CSS 选择器吧，这东西成熟，ai能很好的处理。
下面就是真正的支持自定义 CSS 文件了，不过这种不能支持`全部<->简略`的转换。

回到标题，此扩展到绝大多数代码都是ai生成的，全部都是硅基世界的产品。而独有这篇文档，这千儿八个字，才是我亲力亲为所产出的成果。不过她还是以硅基与二次元结合的形式和大家会面。
最后偷偷告诉大家，如果嫌弃在右边栏中查看时可视面积太小，可以将其拖拽到主窗口区加以使用。

最终经过三次节点，从[半成品](chat/half)到[完成版](chat/final)，又到后来的[修正版](chat/revised)，也算是一个能用的插件了。这几个文件夹中包含有各个阶段与ai的对话导出记录，感兴趣者可以查看一下，了解一下一个小白经由ai协助进行插件/程序开发的过程。修正版中含有这次协作过程中的所有对话。随着对话轮数增加，导出的文件也逐渐增大，最终也在对话达到ai限制的时刻完成了整个插件。

零星的感悟
之前搞不懂为什么好多程序中的函数会有很多参数，尤其是flag形式的开关参数，直到这次才发现，有时候嫩能很好的实现一些类似的功能。这些功能不完全相同，差一部分就使用开关进行控制。
